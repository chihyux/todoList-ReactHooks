{"code":"!function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&n&&\"string\"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,\"a\",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p=\"\",t(t.s=0)}([function(e,n,t){!function(){var e=new Error(\"Cannot find module 'uninstall'\");throw e.code=\"MODULE_NOT_FOUND\",e}(),e.exports=t(1)},function(e,n,t){\"use strict\";e.exports=t(2)},function(e,n,t){\"use strict\";\n/** @license React vundefined\n * eslint-plugin-react-hooks.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function r(e){return\"Identifier\"===e.type?/^use[A-Z0-9].*$/.test(e.name):!(\"MemberExpression\"!==e.type||e.computed||!r(e.property))&&(\"Identifier\"===(e=e.object).type&&\"React\"===e.name)}function a(e){return\"Identifier\"===e.type&&!/^[a-z]/.test(e.name)}function i(e,n){return e.name===n||\"MemberExpression\"===e.type&&\"React\"===e.object.name&&e.property.name===n}function o(e){return!!(e.parent&&e.parent.callee&&i(e.parent.callee,\"forwardRef\"))}function s(e){return!!(e.parent&&e.parent.callee&&i(e.parent.callee,\"memo\"))}function c(e){return\"FunctionDeclaration\"===e.type||\"FunctionExpression\"===e.type&&e.id?e.id:\"FunctionExpression\"===e.type||\"ArrowFunctionExpression\"===e.type?\"VariableDeclarator\"===e.parent.type&&e.parent.init===e?e.parent.id:\"AssignmentExpression\"===e.parent.type&&e.parent.right===e&&\"=\"===e.parent.operator?e.parent.left:\"Property\"!==e.parent.type||e.parent.value!==e||e.parent.computed?\"AssignmentPattern\"!==e.parent.type||e.parent.right!==e||e.parent.computed?void 0:e.parent.left:e.parent.key:void 0}function l(e){function n(){return{isRequired:!1,isSatisfiedRecursively:!1,hasRequiredNodesBelow:!1,children:new Map}}function t(e,t){t=t.split(\".\");var r=!0,a=!1,i=void 0;try{for(var o,s=t[Symbol.iterator]();!(r=(o=s.next()).done);r=!0){var c=o.value,l=e.children.get(c);l||(l=n(),e.children.set(c,l)),e=l}}catch(e){a=!0,i=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw i}}return e}var r=e.dependencies,a=e.declaredDependencies,i=e.optionalDependencies,o=e.externalDependencies,s=e.isEffect,c=n();r.forEach((function(e,n){t(c,n).isRequired=!0,function(e,n,t){n=n.split(\".\");var r=!0,a=!1,i=void 0;try{for(var o,s=n[Symbol.iterator]();!(r=(o=s.next()).done);r=!0){var c=e.children.get(o.value);if(!c)break;t(c),e=c}}catch(e){a=!0,i=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw i}}}(c,n,(function(e){e.hasRequiredNodesBelow=!0}))})),a.forEach((function(e){t(c,e.key).isSatisfiedRecursively=!0})),i.forEach((function(e){t(c,e).isSatisfiedRecursively=!0})),e=new Set;var l=new Set;!function e(n,t,r,a){n.children.forEach((function(n,i){var o=a(i);n.isSatisfiedRecursively?n.hasRequiredNodesBelow&&r.add(o):n.isRequired?t.add(o):e(n,t,r,(function(e){return o+\".\"+e}))}))}(c,e,l,(function(e){return e}));var u=[],d=new Set,f=new Set;return a.forEach((function(e){e=e.key,l.has(e)?-1===u.indexOf(e)?u.push(e):f.add(e):!s||e.endsWith(\".current\")||o.has(e)?d.add(e):-1===u.indexOf(e)&&u.push(e)})),e.forEach((function(e){u.push(e)})),{suggestedDependencies:u,unnecessaryDependencies:d,duplicateDependencies:f,missingDependencies:e}}function u(e){return\"MemberExpression\"!==e.parent.type||e.parent.object!==e||\"current\"===e.parent.property.name||e.parent.computed||null!=e.parent.parent&&\"CallExpression\"===e.parent.parent.type&&e.parent.parent.callee===e.parent?e:u(e.parent)}function d(e){if(\"Identifier\"===e.type)return e.name;if(\"MemberExpression\"!==e.type||e.computed)throw Error(\"Unsupported node type: \"+e.type);return d(e.object)+\".\"+(e=d(e.property))}function f(e){return\"MemberExpression\"!==e.type||\"Identifier\"!==e.object.type||\"React\"!==e.object.name||\"Identifier\"!==e.property.type||e.computed?e:e.property}function p(e,n){for(var t=[e],r=null;t.length;){if(\"Identifier\"===(r=t.shift()).type&&r.name===n.name&&r.range[0]===n.range[0]&&r.range[1]===n.range[1])return r;if(h(r,n)){e=0;for(var a=Object.entries(r);e<a.length;e++){var i=a[e],o=i[1];\"parent\"!==i[0]&&(y(o)?(o.parent=r,t.push(o)):Array.isArray(o)&&o.forEach((function(e){y(e)&&(e.parent=r,t.push(e))})))}}}return null}function y(e){return\"object\"==typeof e&&null!==e&&!Array.isArray(e)&&\"string\"==typeof e.type}function h(e,n){return e.range[0]<=n.range[0]&&e.range[1]>=n.range[1]}n.configs={recommended:{plugins:[\"react-hooks\"],rules:{\"react-hooks/rules-of-hooks\":\"error\",\"react-hooks/exhaustive-deps\":\"warn\"}}},n.rules={\"rules-of-hooks\":{create:function(e){var n=[],t=[];return{onCodePathSegmentStart:function(e){return t.push(e)},onCodePathSegmentEnd:function(){return t.pop()},onCodePathStart:function(){return n.push(new Map)},onCodePathEnd:function(t,i){function l(e,n){var r=l.cache,a=r.get(e.id);if((n=new Set(n)).has(e.id)){e=(r=[].concat(n)).slice(r.indexOf(e.id)+1),r=!0,a=!1;var i=void 0;try{for(var o,s=e[Symbol.iterator]();!(r=(o=s.next()).done);r=!0)p.add(o.value)}catch(e){a=!0,i=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw i}}return 0}if(n.add(e.id),void 0!==a)return a;if(t.thrownSegments.includes(e))a=0;else if(0===e.prevSegments.length)a=1;else{a=0,s=!0,o=!1;var c=void 0;try{i=e.prevSegments[Symbol.iterator]();for(var u;!(s=(u=i.next()).done);s=!0)a+=l(u.value,n)}catch(e){o=!0,c=e}finally{try{s||null==i.return||i.return()}finally{if(o)throw c}}}return e.reachable&&0===a?r.delete(e.id):r.set(e.id,a),a}function u(e,n){var r=u.cache,a=r.get(e.id);if((n=new Set(n)).has(e.id)){e=(r=Array.from(n)).slice(r.indexOf(e.id)+1),r=!0,a=!1;var i=void 0;try{for(var o,s=e[Symbol.iterator]();!(r=(o=s.next()).done);r=!0)p.add(o.value)}catch(e){a=!0,i=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw i}}return 0}if(n.add(e.id),void 0!==a)return a;if(t.thrownSegments.includes(e))a=0;else if(0===e.nextSegments.length)a=1;else{a=0,s=!0,o=!1;var c=void 0;try{i=e.nextSegments[Symbol.iterator]();for(var l;!(s=(l=i.next()).done);s=!0)a+=u(l.value,n)}catch(e){o=!0,c=e}finally{try{s||null==i.return||i.return()}finally{if(o)throw c}}}return r.set(e.id,a),a}function d(e){var n=d.cache,t=n.get(e.id);if(null===t)return 1/0;if(void 0!==t)return t;if(n.set(e.id,null),0===e.prevSegments.length)t=1;else{t=1/0;var r=!0,a=!1,i=void 0;try{for(var o,s=e.prevSegments[Symbol.iterator]();!(r=(o=s.next()).done);r=!0){var c=d(o.value);c<t&&(t=c)}}catch(e){a=!0,i=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw i}}t+=1}return n.set(e.id,t),t}var f=n.pop();if(0!==f.size){var p=new Set;l.cache=new Map,u.cache=new Map,d.cache=new Map;var y=u(t.initialSegment),h=c(i),m=function(e){for(;e;){var n=c(e);if(n&&(a(n)||r(n))||o(e)||s(e))return!0;e=e.parent}return!1}(i),v=h?a(h)||r(h):o(i)||s(i),g=1/0,b=!0,k=!1,w=void 0;try{for(var x,S=t.finalSegments[Symbol.iterator]();!(b=(x=S.next()).done);b=!0){var E=x.value;if(E.reachable){var R=d(E);R<g&&(g=R)}}}catch(e){k=!0,w=e}finally{try{b||null==S.return||S.return()}finally{if(k)throw w}}b=!0,k=!1,w=void 0;try{for(var D,H=f[Symbol.iterator]();!(b=(D=H.next()).done);b=!0){var A=D.value,M=A[0],j=A[1];if(M.reachable){var C=0===M.nextSegments.length?g<=d(M):g<d(M),P=l(M)*u(M),I=p.has(M.id);f=!0,S=!1,x=void 0;try{for(var O,T=j[Symbol.iterator]();!(f=(O=T.next()).done);f=!0){var z=O.value;if(I&&e.report({node:z,message:'React Hook \"'+e.getSource(z)+'\" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'}),v){if(!I&&P!==y){var F='React Hook \"'+e.getSource(z)+'\" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(C?\" Did you accidentally call a React Hook after an early return?\":\"\");e.report({node:z,message:F})}}else if(!i.parent||\"MethodDefinition\"!==i.parent.type&&\"ClassProperty\"!==i.parent.type||i.parent.value!==i){if(h){var N='React Hook \"'+e.getSource(z)+'\" is called in function \"'+e.getSource(h)+'\" that is neither a React function component nor a custom React Hook function.';e.report({node:z,message:N})}else if(\"Program\"===i.type){var U='React Hook \"'+e.getSource(z)+'\" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';e.report({node:z,message:U})}else if(m){var W='React Hook \"'+e.getSource(z)+'\" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';e.report({node:z,message:W})}}else{var _='React Hook \"'+e.getSource(z)+'\" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';e.report({node:z,message:_})}}}catch(e){S=!0,x=e}finally{try{f||null==T.return||T.return()}finally{if(S)throw x}}}}}catch(e){k=!0,w=e}finally{try{b||null==H.return||H.return()}finally{if(k)throw w}}}},CallExpression:function(e){if(r(e.callee)){var a=n[n.length-1],i=t[t.length-1],o=a.get(i);o||(o=[],a.set(i,o)),o.push(e.callee)}}}}},\"exhaustive-deps\":{meta:{schema:[{type:\"object\",additionalProperties:!1,properties:{additionalHooks:{type:\"string\"}}}]},create:function(e){function n(e,n){return function(t){if(n.has(t))return n.get(t);var r=e(t);return n.set(t,r),r}}function t(t){function c(e,n,t,r){return 0===e.size?null:(1<e.size?\"\":n+\" \")+t+\" \"+(1<e.size?\"dependencies\":\"dependency\")+\": \"+function(e){for(var n=\"\",t=0;t<e.length;t++)n+=e[t],0===t&&2===e.length?n+=\" and \":t===e.length-2&&2<e.length?n+=\", and \":t<e.length-1&&(n+=\", \");return n}(Array.from(e).sort().map((function(e){return\"'\"+e+\"'\"})))+\". Either \"+r+\" \"+(1<e.size?\"them\":\"it\")+\" or remove the dependency array.\"}if((\"FunctionExpression\"===t.type||\"ArrowFunctionExpression\"===t.type)&&\"CallExpression\"===t.parent.type){var y=function(e,n){var t=f(e);if(\"Identifier\"!==t.type)return null;switch(t.name){case\"useEffect\":case\"useLayoutEffect\":case\"useCallback\":case\"useMemo\":return 0;case\"useImperativeHandle\":return 1;default:if(t===e&&n&&n.additionalHooks){try{var r=d(t)}catch(e){if(/Unsupported node type/.test(e.message))return 0;throw e}return n.additionalHooks.test(r)?0:-1}return-1}}(t.parent.callee,r);if(t.parent.arguments[y]===t){var m=t.parent.callee,v=f(m).name,g=/Effect($|[^a-z])/g.test(v),b=t.parent.arguments[y+1];if(b||g){g&&t.async&&e.report({node:t,message:\"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\\n\\nuseEffect(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching\"});var k=e.getScope(),w=new Set,x=null;for(y=k.upper;y&&(w.add(y),\"function\"!==y.type);)y=y.upper;if(y){x=y;var S=n((function(e){if(!Array.isArray(e.defs))return!1;var n=e.defs[0];if(null==n||\"VariableDeclarator\"!==n.node.type)return!1;var t=n.node.init;if(null==t)return!1;var r=n.node.parent;if(null==r&&(p(x.block,n.node.id),null==(r=n.node.parent)))return!1;if(\"const\"===r.kind&&\"Literal\"===t.type&&(\"string\"==typeof t.value||\"number\"==typeof t.value||null===t.value))return!0;if(\"CallExpression\"!==t.type)return!1;if(\"MemberExpression\"!==(t=t.callee).type||\"React\"!==t.object.name||null==t.property||t.computed||(t=t.property),\"Identifier\"!==t.type)return!1;if(n=n.node.id,\"useRef\"===(t=t.name)&&\"Identifier\"===n.type)return!0;if((\"useState\"===t||\"useReducer\"===t)&&\"ArrayPattern\"===n.type&&2===n.elements.length&&Array.isArray(e.identifiers)){if(n.elements[1]===e.identifiers[0]){if(\"useState\"===t)for(e=e.references,t=0;t<e.length;t++)a.set(e[t].identifier,n.elements[0]);return!0}if(n.elements[0]===e.identifiers[0]&&\"useState\"===t)for(e=e.references,n=0;n<e.length;n++)i.add(e[n].identifier)}return!1}),o),E=n((function(e){if(!Array.isArray(e.defs))return!1;if(null==(e=e.defs[0])||null==e.node||null==e.node.id)return!1;var n,t=e.node,r=x.childScopes;for(e=null,n=0;n<r.length;n++){var a=r[n],i=a.block;if(\"FunctionDeclaration\"===t.type&&i===t||\"VariableDeclarator\"===t.type&&i.parent===t){e=a;break}}if(null==e)return!1;for(n=0;n<e.through.length;n++)if(null!=(t=e.through[n]).resolved&&w.has(t.resolved.scope)&&!S(t.resolved))return!1;return!0}),s),R=new Map,D=new Map;!function e(n){var r=!0,a=!1,i=void 0;try{for(var o,s=n.references[Symbol.iterator]();!(r=(o=s.next()).done);r=!0){var c=o.value;if(c.resolved&&w.has(c.resolved.scope)){var l,f=u(p(t,c.identifier)),y=d(f);if(l=g&&\"Identifier\"===f.type&&\"MemberExpression\"===f.parent.type&&!f.parent.computed&&\"Identifier\"===f.parent.property.type&&\"current\"===f.parent.property.name){for(var h=c.from,m=!1;h.block!==t;)\"function\"===h.type&&(m=null!=h.block.parent&&\"ReturnStatement\"===h.block.parent.type),h=h.upper;l=m}l&&R.set(y,{reference:c,dependencyNode:f});var v=c.resolved.defs[0];if(null!=v&&(null==v.node||v.node.init!==t.parent)&&\"TypeParameter\"!==v.type)if(D.has(y))D.get(y).references.push(c);else{var b=c.resolved,k=S(b)||E(b);D.set(y,{isStatic:k,references:[c]})}}}}catch(e){a=!0,i=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw i}}r=!0,a=!1,i=void 0;try{for(var x,H=n.childScopes[Symbol.iterator]();!(r=(x=H.next()).done);r=!0)e(x.value)}catch(e){a=!0,i=e}finally{try{r||null==H.return||H.return()}finally{if(a)throw i}}}(k),R.forEach((function(n,t){var r=n.dependencyNode;n=n.reference.resolved.references;for(var a=!1,i=0;i<n.length;i++){var o=n[i].identifier.parent;if(null!=o&&\"MemberExpression\"===o.type&&!o.computed&&\"Identifier\"===o.property.type&&\"current\"===o.property.name&&\"AssignmentExpression\"===o.parent.type&&o.parent.left===o){a=!0;break}}a||e.report({node:r.parent.property,message:\"The ref value '\"+t+\".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '\"+t+\".current' to a variable inside the effect, and use that variable in the cleanup function.\"})}));var H=new Set,A=new Set;if(D.forEach((function(n,t){var r=n.references;n.isStatic&&A.add(t),r.forEach((function(n){n.writeExpr&&(n=n.writeExpr,H.has(t)||(H.add(t),e.report({node:n,message:\"Assignments to the '\"+t+\"' variable from inside React Hook \"+e.getSource(m)+\" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside \"+e.getSource(m)+\".\"})))}))})),!(0<H.size))if(b){var M=[],j=new Set;\"ArrayExpression\"!==b.type?e.report({node:b,message:\"React Hook \"+e.getSource(m)+\" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies.\"}):b.elements.forEach((function(n){if(null!==n)if(\"SpreadElement\"===n.type)e.report({node:n,message:\"React Hook \"+e.getSource(m)+\" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.\"});else{try{var t=d(n)}catch(t){if(/Unsupported node type/.test(t.message))return void(\"Literal\"===n.type?D.has(n.value)?e.report({node:n,message:\"The \"+n.raw+\" literal is not a valid dependency because it never changes. Did you mean to include \"+n.value+\" in the array instead?\"}):e.report({node:n,message:\"The \"+n.raw+\" literal is not a valid dependency because it never changes. You can safely remove it.\"}):e.report({node:n,message:\"React Hook \"+e.getSource(m)+\" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.\"}));throw t}for(var r=n;\"MemberExpression\"===r.type;)r=r.object;var a=!x.through.some((function(e){return e.identifier===r}));M.push({key:t,node:n}),a||j.add(t)}}));var C=l({dependencies:D,declaredDependencies:M,optionalDependencies:A,externalDependencies:j,isEffect:g}),P=C.suggestedDependencies;y=C.unnecessaryDependencies;var I=C.missingDependencies;if(0===(C=C.duplicateDependencies).size+I.size+y.size)(function(e){var n=e.declaredDependenciesNode,t=e.componentScope,r=e.scope;return e.declaredDependencies.map((function(e){if(null==(e=t.set.get(e.key)))return null;var n=e.defs[0];return null==n?null:\"Variable\"===n.type&&\"VariableDeclarator\"===n.node.type&&null!=n.node.init&&(\"ArrowFunctionExpression\"===n.node.init.type||\"FunctionExpression\"===n.node.init.type)||\"FunctionName\"===n.type&&\"FunctionDeclaration\"===n.node.type?e:null})).filter(Boolean).map((function(e){var t=e.defs[0];e:{for(var a=!1,i=0;i<e.references.length;i++){var o=e.references[i];if(o.writeExpr){if(a){e=!0;break e}a=!0}else{for(var s=o.from;s!==r&&null!=s;)s=s.upper;if(s!==r&&!h(n,o.identifier)){e=!0;break e}}}e=!1}return{fn:t,suggestUseCallback:e}}))})({declaredDependencies:M,declaredDependenciesNode:b,componentScope:x,scope:k}).forEach((function(n){var t=n.fn;n=n.suggestUseCallback;var r,a=\"The '\"+t.name.name+\"' function makes the dependencies of \"+v+\" Hook (at line \"+b.loc.start.line+\") change on every render.\";a=n?a+\" To fix this, wrap the '\"+t.name.name+\"' definition into its own useCallback() Hook.\":a+\" Move it inside the \"+v+\" callback. Alternatively, wrap the '\"+t.name.name+\"' definition into its own useCallback() Hook.\",n&&\"Variable\"===t.type&&(r=[{desc:\"Wrap the '\"+t.name.name+\"' definition into its own useCallback() Hook.\",fix:function(e){return[e.insertTextBefore(t.node.init,\"useCallback(\"),e.insertTextAfter(t.node.init,\")\")]}}]),e.report({node:t.node,message:a,suggest:r})}));else{!g&&0<I.size&&(P=l({dependencies:D,declaredDependencies:[],optionalDependencies:A,externalDependencies:j,isEffect:g}).suggestedDependencies),function(){if(0===M.length)return!0;var e=M.map((function(e){return e.key})),n=e.slice().sort();return e.join(\",\")===n.join(\",\")}()&&P.sort();var O=\"\";if(0<y.size){var T=null;if(Array.from(y.keys()).forEach((function(e){null===T&&e.endsWith(\".current\")&&(T=e)})),null!==T)O=\" Mutable values like '\"+T+\"' aren't valid dependencies because mutating them doesn't re-render the component.\";else if(0<j.size){var z=Array.from(j)[0];k.set.has(z)||(O=\" Outer scope values like '\"+z+\"' aren't valid dependencies because mutating them doesn't re-render the component.\")}}if(!O&&I.has(\"props\")){if(null==(k=D.get(\"props\")))return;if(k=k.references,!Array.isArray(k))return;z=!0;for(var F=0;F<k.length;F++){var N=p(x.block,k[F].identifier);if(!N){z=!1;break}if(null==(N=N.parent)){z=!1;break}if(\"MemberExpression\"!==N.type){z=!1;break}}z&&(O=\" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the \"+v+\" call and refer to those specific props inside \"+e.getSource(m)+\".\")}if(!O&&0<I.size){var U=null;I.forEach((function(e){if(!U){var n=x.set.get(e),t=D.get(e);if(t.references[0].resolved===n&&(null!=(n=n.defs[0])&&null!=n.name&&\"Parameter\"===n.type)){n=!1;for(var r,a=0;a<t.references.length;a++)if(null!=(r=t.references[a].identifier)&&null!=r.parent&&\"CallExpression\"===r.parent.type&&r.parent.callee===r){n=!0;break}n&&(U=e)}}})),null!==U&&(O=\" If '\"+U+\"' changes too often, find the parent component that defines it and wrap that definition in useCallback.\")}if(!O&&0<I.size){var W=null;if(I.forEach((function(e){if(null===W)for(var n,t,r=D.get(e).references,o=0;o<r.length;o++){for(t=(n=r[o].identifier).parent;null!=t&&t!==x.block;){if(\"CallExpression\"===t.type){var s=a.get(t.callee);if(null!=s){s.name===e?W={missingDep:e,setter:t.callee.name,form:\"updater\"}:i.has(n)?W={missingDep:e,setter:t.callee.name,form:\"reducer\"}:null!=(n=r[o].resolved)&&(null!=(n=n.defs[0])&&\"Parameter\"===n.type&&(W={missingDep:e,setter:t.callee.name,form:\"inlineReducer\"}));break}}t=t.parent}if(null!==W)break}})),null!==W)switch(W.form){case\"reducer\":O=\" You can also replace multiple useState variables with useReducer if '\"+W.setter+\"' needs the current value of '\"+W.missingDep+\"'.\";break;case\"inlineReducer\":O=\" If '\"+W.setter+\"' needs the current value of '\"+W.missingDep+\"', you can also switch to useReducer instead of useState and read '\"+W.missingDep+\"' in the reducer.\";break;case\"updater\":O=\" You can also do a functional update '\"+W.setter+\"(\"+W.missingDep.substring(0,1)+\" => ...)' if you only need '\"+W.missingDep+\"' in the '\"+W.setter+\"' call.\";break;default:throw Error(\"Unknown case.\")}}e.report({node:b,message:\"React Hook \"+e.getSource(m)+\" has \"+(c(I,\"a\",\"missing\",\"include\")||c(y,\"an\",\"unnecessary\",\"exclude\")||c(C,\"a\",\"duplicate\",\"omit\"))+O,suggest:[{desc:\"Update the dependencies array to be: [\"+P.join(\", \")+\"]\",fix:function(e){return e.replaceText(b,\"[\"+P.join(\", \")+\"]\")}}]})}}else{var _=null;if(D.forEach((function(e,n){_||e.references.forEach((function(e){if(!_&&a.has(e.identifier)){for(e=e.from;\"function\"!==e.type;)e=e.upper;e.block===t&&(_=n)}}))})),_){var q=l({dependencies:D,declaredDependencies:[],optionalDependencies:A,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;e.report({node:t.parent.callee,message:\"React Hook \"+v+\" contains a call to '\"+_+\"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [\"+q.join(\", \")+\"] as a second argument to the \"+v+\" Hook.\",suggest:[{desc:\"Add dependencies array: [\"+q.join(\", \")+\"]\",fix:function(e){return e.insertTextAfter(t,\", [\"+q.join(\", \")+\"]\")}}]})}}}}else\"useMemo\"!==v&&\"useCallback\"!==v||e.report({node:t.parent.callee,message:\"React Hook \"+v+\" does nothing when called with only one argument. Did you forget to pass an array of dependencies?\"})}}}var r={additionalHooks:e.options&&e.options[0]&&e.options[0].additionalHooks?new RegExp(e.options[0].additionalHooks):void 0},a=new WeakMap,i=new WeakSet,o=new WeakMap,s=new WeakMap;return{FunctionExpression:t,ArrowFunctionExpression:t}}}}}]);","extractedComments":[]}